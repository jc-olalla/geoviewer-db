-- 01_viewer_schema.sql (tenant-scoped catalog DB)

-- 1) housekeeping
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;

-- 2) updated_at trigger helper
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3) users (tenant-local), Option A fields
CREATE TABLE IF NOT EXISTS users (
    id             integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username       text NOT NULL UNIQUE,
    password_hash  text,                            -- nullable; system users must NOT have one
    email          text,
    role           text NOT NULL DEFAULT 'user',
    is_system      boolean NOT NULL DEFAULT false,
    is_active      boolean NOT NULL DEFAULT true,
    auth_provider  text NOT NULL DEFAULT 'local',
    created_at     timestamptz NOT NULL DEFAULT now(),
    updated_at     timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT ck_system_has_no_password
      CHECK (NOT is_system OR password_hash IS NULL)
);

-- Re-create trigger idempotently
DROP TRIGGER IF EXISTS trg_users_updated_at ON users;
CREATE TRIGGER trg_users_updated_at
BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Ensure a per-tenant system user exists (idempotent)
INSERT INTO users (username, email, role, is_system, is_active, auth_provider, password_hash)
SELECT 'system', 'system@' || current_database() || '.local', 'admin', true, false, 'local', NULL
WHERE NOT EXISTS (SELECT 1 FROM users WHERE username = 'system');

-- 4) viewers
CREATE TABLE IF NOT EXISTS viewers (
    id          integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name        text NOT NULL,
    slug        text UNIQUE NOT NULL,
    description text,
    owner_id    integer NOT NULL REFERENCES users(id),
    is_public   boolean NOT NULL DEFAULT false,
    created_at  timestamptz NOT NULL DEFAULT now(),
    updated_at  timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_viewers_is_public ON viewers(is_public);

DROP TRIGGER IF EXISTS trg_viewers_updated_at ON viewers;
CREATE TRIGGER trg_viewers_updated_at
BEFORE UPDATE ON viewers FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- 5) layers
CREATE TABLE IF NOT EXISTS layers (
    id           integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type         text NOT NULL CHECK (type IN (
                   'wms','wfs','wcs','file','xyz','vector',
                   'http','ogc_features','supabase_rest','rest'
                 )),
    name         text NOT NULL,
    title        text,
    url          text,
    layer_name   text,
    version      text,
    crs          text NOT NULL DEFAULT 'EPSG:3857',
    format       text,
    tiled        boolean NOT NULL DEFAULT false,
    opacity      real NOT NULL DEFAULT 1.0 CHECK (opacity >= 0 AND opacity <= 1),
    visible      boolean NOT NULL DEFAULT true,
    min_zoom     integer,
    max_zoom     integer,
    sort_order   integer,
    layer_params jsonb,
    extra_config jsonb,
    bbox         jsonb,
    created_at   timestamptz NOT NULL DEFAULT now(),
    updated_at   timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT ck_zoom_range CHECK (
        min_zoom IS NULL OR max_zoom IS NULL OR min_zoom <= max_zoom
    )
);

CREATE INDEX IF NOT EXISTS idx_layers_viewer_sort       ON layers(viewer_id, sort_order, id);
CREATE INDEX IF NOT EXISTS idx_layers_viewer_vis        ON layers(viewer_id, visible);
CREATE INDEX IF NOT EXISTS idx_layers_name_title        ON layers (lower(name), lower(title));
CREATE INDEX IF NOT EXISTS idx_layers_params_gin        ON layers USING GIN (layer_params);
CREATE INDEX IF NOT EXISTS idx_layers_extraconfig_gin   ON layers USING GIN (extra_config);

DROP TRIGGER IF EXISTS trg_layers_updated_at ON layers;
CREATE TRIGGER trg_layers_updated_at
BEFORE UPDATE ON layers FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- 6) viewer_permissions (users ↔ viewers)
CREATE TABLE IF NOT EXISTS viewer_permissions (
    id           integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    viewer_id    integer NOT NULL REFERENCES viewers(id) ON DELETE CASCADE,
    user_id      integer NOT NULL REFERENCES users(id)   ON DELETE CASCADE,
    access_level text NOT NULL DEFAULT 'read' CHECK (access_level IN ('read','edit','owner')),
    created_at   timestamptz NOT NULL DEFAULT now(),
    updated_at   timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT uq_viewer_user UNIQUE (viewer_id, user_id)
);
CREATE INDEX IF NOT EXISTS idx_vp_viewer ON viewer_permissions(viewer_id);
CREATE INDEX IF NOT EXISTS idx_vp_user   ON viewer_permissions(user_id);

DROP TRIGGER IF EXISTS trg_vp_updated_at ON viewer_permissions;
CREATE TRIGGER trg_vp_updated_at
BEFORE UPDATE ON viewer_permissions FOR EACH ROW EXECUTE FUNCTION set_updated_at();

--------------------------------------------------------------------------------
-- 7) NEW: layer_permissions (viewers ↔ layers)
-- Purpose: control the relationship and permissions between a viewer and its layers.
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS layer_permissions (
    id            integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    viewer_id     integer NOT NULL REFERENCES viewers(id) ON DELETE CASCADE,
    layer_id      integer NOT NULL REFERENCES layers(id)  ON DELETE CASCADE,
    access_level  text NOT NULL DEFAULT 'read' CHECK (access_level IN ('read','edit','owner')),
    default_visible boolean NOT NULL DEFAULT true,
    can_toggle    boolean NOT NULL DEFAULT true,
    sort_order_override integer,                       -- optional UI ordering override
    min_zoom_override   integer,                       -- optional per-viewer zoom gates
    max_zoom_override   integer,
    created_at    timestamptz NOT NULL DEFAULT now(),
    updated_at    timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT uq_layer_permissions UNIQUE (viewer_id, layer_id),
    CONSTRAINT ck_lp_zoom_range CHECK (
        min_zoom_override IS NULL OR max_zoom_override IS NULL OR min_zoom_override <= max_zoom_override
    )
);
CREATE INDEX IF NOT EXISTS idx_lp_viewer ON layer_permissions(viewer_id);
CREATE INDEX IF NOT EXISTS idx_lp_layer  ON layer_permissions(layer_id);

DROP TRIGGER IF EXISTS trg_lp_updated_at ON layer_permissions;
CREATE TRIGGER trg_lp_updated_at
BEFORE UPDATE ON layer_permissions FOR EACH ROW EXECUTE FUNCTION set_updated_at();


--------------------------------------------------------------------------------
-- 8) NEW: styles (re-usable style JSON objects)
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS styles (
    id           integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name         text NOT NULL,
    json         jsonb NOT NULL,                         -- GeoStyler-like rules dict
    created_by   integer REFERENCES users(id),
    created_at   timestamptz NOT NULL DEFAULT now(),
    updated_at   timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_styles_name_lower ON styles (lower(name));
CREATE INDEX IF NOT EXISTS idx_styles_json_gin   ON styles USING GIN (json);

DROP TRIGGER IF EXISTS trg_styles_updated_at ON styles;
CREATE TRIGGER trg_styles_updated_at
BEFORE UPDATE ON styles FOR EACH ROW EXECUTE FUNCTION set_updated_at();

--------------------------------------------------------------------------------
-- 9) NEW: layer_styles (bind a style to a layer)
-- One row per layer is typical. If you later want multiple styles per layer
-- or per-scale alternates, you can evolve this to allow multiple rows.
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS layer_styles (
    layer_id   integer PRIMARY KEY REFERENCES layers(id) ON DELETE CASCADE,
    style_id   integer NOT NULL REFERENCES styles(id),
    enabled    boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

DROP TRIGGER IF EXISTS trg_layer_styles_updated_at ON layer_styles;
CREATE TRIGGER trg_layer_styles_updated_at
BEFORE UPDATE ON layer_styles FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Convenience index if you often fetch layers by style
CREATE INDEX IF NOT EXISTS idx_layer_styles_style ON layer_styles(style_id);

